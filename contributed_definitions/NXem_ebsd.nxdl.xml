<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="nxdlformat.xsl"?>
<!--
# NeXus - Neutron and X-ray Common Data Format
# 
# Copyright (C) 2014-2022 NeXus International Advisory Committee (NIAC)
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For further information, see http://www.nexusformat.org
-->
<!--The respective partner application definition NXxray_fourd
can be used for storing data and post-processing results of X-ray diffraction
experiments which can yield also orientation maps in one, two- or three-dimensions.
These complementary techniques and associated application definitions can be used
to inform NXms, another partner application definition to NXem_ebsd. NXms describes
the connection between measured or simulated structural features with a focus of
the length and time-scale coarser then the atomic scale. The term microstructure
is used here but is not restricted to features at the micron scale.
the IUCr DMI should work on an e.g. NXhedm
NXem_tkd is not needed as it can be covered by NXem_ebsd as well.
if we think of the metadata/data graph collected from the microscope session
documented in NXem there may be only a few relations between nodes of an instance
of NXem_ebsd and NXem. Key data from NXem which many users would expect to find
also enumerated in NXem_ebsd could be settings of the microscope, timestamp data
when tasks were performed at the microscope using which specimen, operated
and prepared by whom. These latter pieces of information are all available
in NXem but if we were to make fields in NXem deep inside an instance
of NXem_event_data required than we factually more and more granularize and
pull in steps of detailed numerical post-processing which arguably is not
any longer at all necessarily related to the microscope session.
We know many cases in EBSD community, see the work of e.g. Marc de Graef's group
or of Hakon Wiik Anes and Knut Marthinsen who spent much longer with a collected
dataset in post-processing than collecting it at the microscope. Therefore, we
need to have the flexibility that documentation of the actual microscope session
and the post-processing of some of the data therein collected remain coupled
but not too repetively and with too stiff constraints on the existence of specific
fields as otherwise there can be contradictions for which NXem_ebsd would no longer
be applicable when one wishes to remain at the same time conformant with the data
scheme.
The idea used here is to use a reference to another NeXus file in the NXem_ebsd
file instance and the NXem file instance. So far we acknowledge that exporting
data as an NXem application definition is limited and scientists currently have
specific file formats from commercial or open-source tools to work with.
Therefore, we so far model the connections between the application definitions
as NXprocesses. As soon as NXem is more supported these NXclasses should become
NXem e.g. though.
Details about scan positions should not be reproduced unless needed for
interpolating between results of neighboring scan positions.
Currently, we suggest to leave the scan positions as closely to where they are
collected, i.e. inside NXem.
What this exampe of linking information rather than duplicating shows is that
somewhat a culture change is needed: Instead of packing everything in one file
we just need to assure that we have a tool whereby we can follow and inspect a
set of linked objects if you would like to say so, also having multiple files
is okay.
Finally, this application definition makes any assumptions about
gridding, this enables to handle all sort of scan schemes.
We follow the argumentation of MTex, in certain cases data will not yield
fully occupied grids anyway.
NXem_ebsd could also be useful/used for storing generic simulations of EBSD pattern
which is one example for simulations of diffractions patterns as they may be observed
with electron microscopes. In this case, there should be simulation(NXprocess) under this
the simulation group where one can store the minimum required set of pieces of information
which comes with every diffraction pattern simulation.
The main problem is in this case that the simulation group is required but then there must
either be no measurement group and on_the_fly_indexing group, and eventually calibration ?
or these groups should be created but remain empty.
Using the current NeXus appdef design and rules for setting constraints demands that then the
same appdef should be used for post-processing measured data. So there is a conflict:
The simulation must not be required and measurement must not be optional.
Arguably one may call for two application definitions in this case but most constraints and
concepts would then match those of NXem_ebsd which works again standardization and
reducing the total number of ontologies.-->
<definition xmlns="http://definition.nexusformat.org/nxdl/3.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" category="base" type="group" name="NXem_ebsd" extends="NXem_method" xsi:schemaLocation="http://definition.nexusformat.org/nxdl/3.1 ../nxdl.xsd">
    <symbols>
        <symbol name="n_op">
            <doc>
                 Number of arguments per orientation for given parameterization.
            </doc>
        </symbol>
        <symbol name="n_sc">
            <doc>
                 Number of scan points.
            </doc>
        </symbol>
        <symbol name="n_z">
            <doc>
                 Number of pixel along the slowest changing dimension for a rediscretized, 
                 i.e. standardized default plot orientation mapping.
            </doc>
        </symbol>
        <symbol name="n_y">
            <doc>
                 Number of pixel along slow changing dimension for a rediscretized i.e.
                 standardized default plot orientation mapping.
            </doc>
        </symbol>
        <symbol name="n_x">
            <doc>
                 Number of pixel along fast changing dimension for a rediscretized i.e.
                 standardized default plot orientation mapping.
            </doc>
        </symbol>
    </symbols>
    <doc>
         Base class method-specific for Electron Backscatter Diffraction (EBSD).
    </doc>
    <group name="conventions" type="NXem_conventions"/>
    <!--either we have simulated data or we have a set of measured data
in every case data are Kikuchi diffraction pattern and their metadata-->
    <group name="measurement" type="NXprocess">
        <doc>
             This group documents relevant details about the conditions and the tools
             used for measuring a stack of Kikuchi diffraction pattern with an
             electron microscope.
        </doc>
        <field name="info"/>
        <!--The em_om parser will currently not interpret the majority of the
many system- and technique-specific metadata which come with the
files from e.g. technology partners. This is because the current
culture in the EBSD community is that many of the metadata fields
are neither in all cases fully documented nor use a standardized
vocabulary although many people understand terms from different
implementations and how these metadata can likely be compared to
one another.

In addition, it is common practice in the research field of EBSD that
users transcode their raw data into other (often text-based or HDF5)
files with custom formatting to realize an information transfer
between specific software tools including commercial software from
technology partner, custom scripts in Matlab using tools like MTex,
or Python scripting with tools like hyperspy, pyxem, orix, diffsims,
kikuchipy, or EBSD data stack alignment tools like DREAM.3D.
We have opted that in the first iteration this implementation of a
RDMS-agnostic FAIR data schema for EBSD that we discard these metadata
because these ad hoc file formats are not designed to communicate
also specifically and most importantly the eventually different context
of the metadata.
Another reason for this choice was also to emphasize that in fact such
challenges do exist in the community and thus pointing them out may
support the discussion to arrive at eventually more complete solutions.
As developing these solutions should not be our authority and necessarily
demands feedback from the technology partners, we have opted for this
intermediate approach to stimulate discussion.
sequence_index(N):
  unit: NX_UNITLESS-->
        <field name="time" type="NX_FLOAT" units="NX_TIME">
            <doc>
                 Physical time since the beginning of a timestamp that is required to be
                 same for all experiments in the set. The purpose of this marker is
                 to identify how all experiments in the set have have to be arranged
                 sequentially based on the time elapsed.
                 The time is relevant to sort e.g. experiments of consecutive quasi
                 in-situ experiments where a measurement was e.g. taken after 0 minutes
                 of annealing, 30 minutes, 6 hours, or 24 hours of annealing.
            </doc>
        </field>
        <!--(NXtransformations):
  doc: |
    Transformation which details where the region-of-interest described under
    indexing is located in absolute coordinates and rotation with respect
    to which coordinate system.-->
        <field name="pattern_available" type="NX_BOOLEAN">
            <doc>
                 True if either the depends_on or origin field specify the actual
                 Kikuchi pattern stack with which the indexing is performed.
                 False if this information is not available.
            </doc>
        </field>
        <field name="depends_on">
            <doc>
                 Reference to a location (in an application definition instance) which
                 specifies the stack. If this field is used, the reference has to point
                 to an existent instance of NXimage_r_set_diff.
                 
                 Alternatively, use origin if the Kikuchi pattern stack or already processed
                 data which should be used as input is available. A typical example is a
                 file in common formats e.g. HDF5, CPR, CTF, etc.
            </doc>
        </field>
        <field name="origin">
            <doc>
                 Reference (e.g. path and filename) to an existent data artifact which
                 stores either the pattern or input (already processed EBSD data)
                 which is now processed further as described by this NXem_ebsd instance.
            </doc>
            <attribute name="version">
                <doc>
                     Commit identifying this resource or at least an as strong as SHA256
                     hash generated from the content of the data artifact.
                </doc>
            </attribute>
        </field>
    </group>
    <group name="simulation" type="NXprocess">
        <doc>
             This group documents relevant details about the conditions and the tools
             used for simulating a stack of Kikuchi diffraction pattern with some
             physical model.
             
             This group should not be confused with a group named simulation that
             is however an instance of NXem_sim. Instead, the simulation group here
             should be used if (e.g. instead of a measurement) a stack of pattern
             were simulated which one is interested afterwards to index.
             
             In many practical cases where pattern are analyzed on-the-fly and dictionary
             indexing strategies are used so-called master pattern(s) are used to compare
             measured or simulated pattern with the master pattern. In this case,
             master pattern are the result of a computer simulation and thus should
             be stored using in an own properly documented entry with a simulation
             group which is an instance of NXem_sim. In this case the specific
             NXem_ebsd_crystal_structure_model instances should refer to these simulations.
        </doc>
        <field name="pattern_available" type="NX_BOOLEAN">
            <doc>
                 True if either the depends_on or origin field specify the actual
                 Kikuchi pattern stack with which the indexing is performed.
                 False if this information is not available.
            </doc>
        </field>
        <field name="depends_on">
            <doc>
                 Reference to a location (in an application definition instance) which
                 specifies the stack. If this field is used, the reference has to point
                 to an existent instance of NXimage_r_set_diff.
                 
                 Alternatively, use origin if the Kikuchi pattern stack or already processed
                 data which should be used as input is available. A typical example is a
                 file in common formats e.g. HDF5, CPR, CTF, etc.
            </doc>
        </field>
        <field name="origin">
            <doc>
                 Reference (e.g. path and filename) to an existent data artifact which
                 stores either the pattern or input (already processed EBSD data)
                 which is now processed further as described by this NXem_ebsd instance.
            </doc>
            <attribute name="version">
                <doc>
                     Commit identifying this resource or at least an as strong as SHA256
                     hash generated from the content of the data artifact.
                </doc>
            </attribute>
        </field>
    </group>
    <group name="calibration" type="NXprocess">
        <doc>
             The EBSD system, including components like the electron gun, pole-piece,
             stage tilting, EBSD detector, and the gnomonic projection have to be
             calibrated to achieve reliable indexing results. Specifically,
             the gnomonic projection has to be calibrated. Typically silicon or
             quartz crystals are used for this purpose.
        </doc>
        <field name="info"/>
        <field name="sequence_index" type="NX_POSINT"/>
        <field name="calibration_available" type="NX_BOOLEAN">
            <doc>
                 True if calibration data are available and resolvable via either
                 depends_on or origin.
            </doc>
        </field>
        <field name="depends_on">
            <doc>
                 Reference to a location (in an application definition instance) which
                 specifies a calibration measurement. If this field is used,
                 the reference has to point to an instance of NXem_base.
                 
                 Alternatively, use origin if a calibration measurement is available
                 only as a file.
            </doc>
        </field>
        <field name="origin">
            <doc>
                 Reference (e.g. path and filename) to an existent data artifact which
                 stores either a log of the calibration measurement.
            </doc>
            <attribute name="version">
                <doc>
                     Commit identifying this resource or at least an as strong as SHA256
                     hash generated from the content of the data artifact.
                </doc>
            </attribute>
        </field>
    </group>
    <group name="indexing" type="NXprocess">
        <doc>
             Indexing is a data processing step performed either after or while
             (on-the-fly) the beam scans the specimen. The resulting method is also
             known as orientation imaging microscopy (OIM).
             
             Different algorithms can be used to index EBSD/EBSP pattern. Common to them
             is the computational step where simulated reference pattern are compared
             with measured or simulated patterns. These latter patterns are referred
             to via the measurement or simulation groups of this base class.
             
             Quality descriptors are defined based on which an indexing algorithm
             yields a quantitative measure of how similar measured and reference
             pattern are, and thus if no, one, or multiple so-called solutions
             were found.
        </doc>
        <field name="info"/>
        <!--sequence_index(N):-->
        <group name="on_the_fly_indexing" type="NXprocess">
            <doc>
                 This group provides a compromise for the dilemna and approach whereby
                 to document steps of on-the-fly processing.
            </doc>
            <field name="depends_on">
                <doc>
                     Reference to the relevant group (either measurement, simulation, 
                     or calibration inside this NXem_ebsd group) which resolves the
                     data artifact which was generated from this on_the_fly_indexing step.
                </doc>
            </field>
        </group>
        <field name="method">
            <doc>
                 Principal algorithm used for indexing.
            </doc>
            <enumeration>
                <item value="undefined"/>
                <item value="hough_transform"/>
                <item value="dictionary"/>
                <item value="radon_transform"/>
                <item value="other"/>
            </enumeration>
        </field>
        <group name="background_correction" type="NXprocess">
            <doc>
                 Details about the background correction applied to each Kikuchi pattern.
            </doc>
            <field name="sequence_index" type="NX_POSINT"/>
        </group>
        <!--for each process the program used
auto_background_correction:
static_or_dynamic:
pattern_averaging(NXprocess):
doc: |
Details about how patterns of each scan point are average or how
pattern from scan points and neighboring scan points are spatially
averaged (using weighting schemes and e.g. kernels) before these
patterns are passed to the indexing algorithm.-->
        <group name="binning" type="NXprocess">
            <doc>
                 Binning i.e. downsampling of the pattern.
            </doc>
            <field name="sequence_index" type="NX_POSINT"/>
        </group>
        <!--for each process the program used
mode:
doc: Free-text description for instrument specific settings
binning(NX_UINT): ##MK equivalent to pattern height and width?
doc: |
How is the camera signal binned.
First the number of pixel along the slow direction.
Second the number of pixel along the fast direction.
unit: NX_UNITLESS
dimensions:
rank: 1
dim: [[1, 2]]-->
        <group name="parameter" type="NXprocess">
            <doc>
                 Specific parameter relevant only for certain algorithms used
            </doc>
            <field name="sequence_index" type="NX_POSINT"/>
        </group>
        <!--mode:
doc: Which method used to index pattern?
enumeration: [optimize_bd]  # what does optimize_bd mean Oxford?-->
        <group type="NXem_ebsd_crystal_structure_model"/>
        <!--connection to data collected using kinematic or
NEW ISSUE: dynamic diffraction theory simulations
individual mappings
(scientists in EBSD consult all sorts of mappings)
like image_quality map, orientation mapping, ipf mapping, grain mapping
etc. in fact these could be all the possible mappings which one can
create with the famous commercial software solutions
the problem a RDMS cannot understand these mappings unless they
are standardized in the sense, one has an exchange format whereby
these mappings can be exported/transcoded from their representation
in the commercial software, e.g.
keep in mind, everybody uses the TSL OIM or Bruker AZTec OIM mapping
but even these two are not directly interoperable, which is why
they are also not interoperable in some RDMS if one does not come
up with a way how to go about standardizing their description
summary(NXdata):
doc: |-->
        <!--data(NX_UINT):
doc: |
Status value of each pixel of the orientation mapping.-->
        <field name="status" type="NX_UINT" units="NX_UNITLESS">
            <doc>
                 Which return value did the indexing algorithm yield for each scan point.
                 Practically useful is to use an uint8 mask.
                 
                 * 0 - Not analyzed
                 * 1 - Too high angular deviation
                 * 2 - No solution
                 * 100 - Success
                 * 255 - Unexpected errors
            </doc>
            <dimensions rank="1">
                <dim index="1" value="n_sc"/>
            </dimensions>
        </field>
        <field name="n_phases_per_scan_point" type="NX_UINT" units="NX_UNITLESS">
            <doc>
                 How many phases i.e. crystal structure models were used to index each
                 scan point if any? Let's assume an example to explain how this field
                 should be used: In the simplest case users collected one pattern for
                 each scan point and have indexed using one phase, i.e. one instance
                 of an NXem_ebsd_crystal_structure_model.
                 
                 In another example users may have skipped some scan points (not indexed)
                 them at all) and/or used differing numbers of phases for different scan
                 points.
                 
                 The cumulated of this array decodes how phase_identifier and phase_matching
                 arrays have to be interpreted. In the simplest case (one pattern per scan
                 point, and all scan points indexed using that same single phase model),
                 phase_identifier has as many entries as scan points
                 and phase_matching has also as many entries as scan points.
            </doc>
            <dimensions rank="1">
                <dim index="1" value="n_sc"/>
            </dimensions>
        </field>
        <field name="phase_identifier" type="NX_UINT" units="NX_UNITLESS">
            <doc>
                 The array n_phases_per_scan_point details how the phase_identifier
                 and the phase_matching arrays have to be interpreted.
                 
                 For the example with a single phase phase_identifier has trivial
                 values either 0 (no solution) or 1 (solution matching
                 sufficiently significant with the model for phase 1).
                 
                 When there are multiple phases, it is possible (although not frequently
                 needed) that a pattern matches eventually (not equally well) sufficiently
                 significant with multiple pattern. This can especially happen in cases of
                 pseudosymmetry and more frequently with an improperly calibrated system
                 or false or inaccurate phase models e.g. (ferrite, austenite).
                 Having such field is especially relevant for recent machine learning
                 or dictionary based indexing schemes because in combination with
                 phase_matching these fields communicate the results in a model-agnostic
                 way.
                 
                 Depending on the n_phases_per_scan_point value phase_identifier and
                 phase_matching arrays represent a collection of concatenated tuples,
                 which are organized in sequence: The solutions for the 0-th scan point,
                 the 1-th scan point, the n_sc - 1 th scan point and omitting tuples
                 for those scan points with no phases according to n_phases_per_scan_point
            </doc>
            <dimensions rank="1">
                <dim index="1" value="i"/>
            </dimensions>
        </field>
        <field name="phase_matching" type="NX_UINT" units="NX_UNITLESS">
            <doc>
                 One-dimensional array, pattern by pattern labelling the solutions found.
                 The array n_phases_per_scan_point has to be specified because it details
                 how the phase_identifier and the phase_matching arrays have to be interpreted.
                 See documentation of phase_identifier for further details.
            </doc>
            <dimensions rank="1">
                <dim index="1" value="i"/>
            </dimensions>
        </field>
        <field name="phase_matching_descriptor">
            <doc>
                 Phase_matching is a descriptor for how well the solution matches or not.
                 Examples can be confidence index (ci), mean angular deviation (mad),
                 some AI-based matching probability (other), i.e. the details are implementation-specific.
            </doc>
            <enumeration>
                <item value="undefined"/>
                <item value="ci"/>
                <item value="mad"/>
                <item value="other"/>
            </enumeration>
        </field>
        <group type="NXrotation_set"/>
        <field name="scan_point_positions" type="NX_FLOAT" units="NX_LENGTH">
            <!--we make this only required as people may not yet be so happy with
having to walk a graph from measurement -> path -> NXevent_data_em
-> em_lab/ebeam_deflector to retrieve the actual scan positions
although this would be much cleaner-->
            <doc>
                 Matrix of calibrated center positions of each scan point
                 in the sample surface reference system.
            </doc>
            <dimensions rank="2">
                <dim index="1" value="n_sc"/>
                <dim index="2" value="2"/>
            </dimensions>
        </field>
        <!--EW ISSUE: this is in fact a duplicate because if we know th
path to the measurement we would have available all ebeam_deflector
settings and thus could identify where the beam was scanning for each
NXevent_data_em instance, we have even more
NEW ISSUE: replace by a more generic pivot table-->
        <field name="indexing_rate" type="NX_FLOAT" units="NX_DIMENSIONLESS">
            <doc>
                 Fraction of successfully indexed pattern with a phase not the
                 null-phase vs the total number of scan points.
            </doc>
        </field>
        <field name="number_of_scan_points" type="NX_UINT" units="NX_UNITLESS">
            <doc>
                 Number of scan points in the original mapping.
            </doc>
        </field>
        <group type="NXms_odf_set"/>
        <group type="NXms_pf_set"/>
        <group type="NXms_recon"/>
        <!--overview over the entire map, rediscretized on a tight aabb-->
        <group name="roi" type="NXdata">
            <doc>
                 An overview of the entire area which was scanned processed from
                 the entire scan area but eventually downsampled.
            </doc>
            <field name="descriptor">
                <doc>
                     Descriptor representing the image contrast.
                </doc>
                <!--taking two examples (CTF and H5OINA choked completely of possibility to find s.th. conceptually common to plot-->
                <enumeration>
                    <item value="normalized_band_contrast"/>
                    <item value="normalized_confidence_index"/>
                </enumeration>
            </field>
            <!--\@signal:  # data
\@axes:  # [axis_y, axis_x]
\@axis_x_indices: 0
\@axis_y_indices: 1
\@signal:
\@axes:
\@AXISNAME_indices:
\@long_name:-->
            <field name="title">
                <doc>
                     Title of the default plot.
                </doc>
            </field>
            <field name="data" type="NX_FLOAT" units="NX_UNITLESS">
                <doc>
                     Descriptor values displaying the ROI.
                </doc>
                <dimensions rank="2">
                    <dim index="1" value="n_y"/>
                    <dim index="2" value="n_x"/>
                </dimensions>
                <!--n_0 slow 2, n_1 fast 1, rgb triplet is fastest 0
in axes fast to fastest
while for _indices fastest to fast-->
                <attribute name="long_name">
                    <doc>
                         Descriptor values.
                    </doc>
                </attribute>
            </field>
            <field name="axis_y" type="NX_FLOAT" units="NX_LENGTH">
                <doc>
                     Calibrated coordinate along the y-axis.
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="n_y"/>
                </dimensions>
                <attribute name="long_name">
                    <doc>
                         Label for the y axis
                    </doc>
                </attribute>
            </field>
            <field name="axis_x" type="NX_FLOAT" units="NX_LENGTH">
                <doc>
                     Calibrated coordinate along the x-axis.
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="n_x"/>
                </dimensions>
                <attribute name="long_name">
                    <doc>
                         Label for the x axis
                    </doc>
                </attribute>
            </field>
        </group>
    </group>
    <!--further ideas
what to do when multiple pattern are averaged into one before the beam moves further?
NEW ISSUE: frame averaging
NEW ISSUE: going towards the level of suggestions what would all be immediately possible
ebsd_mapping(NXprocess):
doc: |
An EBSD mapping is the result of a collecting and indexing of Kikuchi
pattern, so that for each pattern there is either an associated
phase_identifier or a status marker stating that no solution was found
(NXsst_color_model): ##MK
doc: |
For each stereographic standard triangle, (fundamental zone) of
the orientation space, it is possible to define a color model which
associates an orientation in the fundamental zone to a color.
For details see:
* [G. Nolze et al.](https://doi.org/10.1107/S1600576716012942)
* Srikanth Patala and coworkers"'" work and of others.
(NXorientation_set):
doc: |
Collection of quaternions in the SO3 fundamental zone with colors and
rgb(NX_NUMBER):
doc: RGB colors.
unit: NX_UNITLESS
dimensions: [[1, n_oris], [2, 3]]
hsv and other models
(NXcg_point_set):
rgb(NX_NUMBER):
dimensions: [[1, n_points], [2, 3]]
mapping(NX_NUMBER):
doc: |
The EBSD mapping with colors outlined
unit: NX_UNITLESS
dimensions: [[1, n_y], [2, n_x], [3, 3]]
NEW ISSUE: it would also be possible to define additional color models to overlay
check n_p vs n_sc vs n_p_or_z-->
    <!--confidence_index(NX_FLOAT):
doc: |
Is a technology-partner-specific (TSL OIM) AMETEK phase_matching descriptor.
unit: NX_UNITLESS
dimensions:
rank: 1
dim: [[1, i]]
mean_angular_deviation(NX_FLOAT):
doc: |
The mean angular deviation is also a technology-partner-specific
(HKL Channel5) solution-to-reflector matching descriptor.
unit: NX_ANGLE
dimensions:
rank: 1
dim: [[1, i]]
there are many other type of descriptor especially for new machine learning
type and dictionary type indexing methods
some descriptors are relevant only for Hough based indexing and technology-partner-specific
band_count(NX_UINT):
doc: |
How many bands were detected in the pattern.
unit: NX_UNITLESS
dimensions:
rank: 1
dim: [[1, n_p]]
band_minimum(NX_UINT):
doc: |
Minimum number of bands required to index the pattern
unit: NX_UNITLESS
dimensions:
rank: 1
dim: [[1, n_p]]
band_maximum(NX_UINT):
doc: |
Maximum number of bands required to index the pattern
unit: NX_UNITLESS
dimensions:
rank: 1
dim: [[1, n_p]]
resolution(NX_NUMBER):
doc: |
Resolution in Hough space.
unit: NX_ANGLE  # or NX_ANY
band_detection(NXprocess):  # for hough_transform
mode:
doc: |
How are Kikuchi bands detected
enumeration: [center]
band_contrast(NX_NUMBER):
doc: |
Value for band contrast descriptor.
unit: NX_UNITLESS
dimensions:
rank: 1
dim: [[1, n_p]]
band_slope(NX_NUMBER):
doc: |
Value for band slope descriptor.
unit: NX_UNITLESS
dimensions:
rank: 1
dim: [[1, n_p]]
centre(NX_FLOAT):
doc: |
Pattern centre location used for analyzing each pattern.
unit: NX_LENGTH
dimensions:
rank: 2
dim: [[1, n_p], [2, 2]]  # what to do when a different one for each pattern seldom but possible
distance(NX_FLOAT):
doc: |
Pattern centre distance used for analyzing each pattern.
unit: NX_LENGTH
dimensions:
rank: 2
dim: [[1, n_p], [2, 2]]
vh_ratio(NX_FLOAT):
doc: |
TBD Oxford/HKL Channel 5 CPR files
unit: NX_DIMENSIONLESS
how to parameterize a group with value, and descriptor type or a
field with descriptor type as attribute?
pattern_quality(NXprocess):
value(NX_NUMBER):
doc: |
Pattern quality descriptor
unit: NX_UNITLESS
dimensions:
rank: 1
dim: [[1, n_p]]
model:
doc: |
Model used to describe some aspect of the pattern.
enumeration: [band_contrast, mean_angular_deviation]
tilt_angle(NX_FLOAT):
maybe better make this integrated into the NXtransformations of the stage_lab, a stage_lab event?
beam_position(NXcg_point_set):
(NXdetector):
exposure_time(NX_TIME):
gain(NX_FLOAT):
#MK how does a gain translate mathematically an input signal into an intensity signal?
insertion_distance(NX_FLOAT):
unit: NX_LENGTH
#MK a coordinate system for the detector in the NXcoordinate_system_set
drift_correction(NX_BOOLEAN): ##MK??
move the next two rather to detector
acquisition_speed(NX_FLOAT):
doc: |
Average number of patterns taken per second averaged over entire set.
unit: NX_FREQUENCY
acquisition_time(NX_TIME):
doc: Wall-clock time the acquisition took.-->
</definition>

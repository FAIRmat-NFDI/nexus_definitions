category: application
doc: |
  Application definition for results files of the paraprobe-spatstat tool.
  
  This tool is part of the paraprobe-toolbox. Inspect the base class :ref:`NXapm_paraprobe_tool_results`.
symbols:
  doc: |
    The symbols used in the schema to specify e.g. dimensions of arrays.
  n_ions: |
    The total number of ions in the reconstruction.
  n_feat: |
    Number of clusters found.
type: group
NXapm_paraprobe_clusterer_results(NXobject):
  (NXentry):
    exists: ['min', '1', 'max', '1']
    definition(NX_CHAR):
      \@version(NX_CHAR):
      enumeration: [NXapm_paraprobe_clusterer_results]
    
    # tasks
    cameca_to_nexus(NXapm_paraprobe_tool_results):
      exists: optional
    CLUSTER_ANALYSIS(NXapm_paraprobe_tool_results):
      nameType: any
      exists: ['min', '0', 'max', 'unbounded']
      identifier_analysis(NX_UINT):
      config(NXnote):
        type(NX_CHAR):
        file_name(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
      window(NXcs_filter_boolean_mask):
        number_of_ions(NX_UINT):
        bitdepth(NX_UINT):
        mask(NX_UINT):
      
      # results
      dbscanID(NXsimilarity_grouping):
        exists: ['min', '0', 'max', 'unbounded']
        nameType: partial
        doc: |
          Results of a DBScan clustering analysis.
        eps(NX_FLOAT):
          unit: NX_LENGTH
          doc: |
            The epsilon (eps) parameter used.
        min_pts(NX_UINT):
          unit: NX_UNITLESS
          doc: |
            The minimum points (min_pts) parameter used.
        cardinality(NX_POSINT):
          unit: NX_UNITLESS
          doc: |
            Number of members in the set which is partitioned into features.
            Specifically, this is the total number of targets filtered from the
            dataset, i.e. typically the number of clusters which is usually not and
            for sure not necessarily the total number of ions in the dataset.
        index_offset(NX_INT):
          unit: NX_UNITLESS
          doc: |
            Which identifier is the first to be used to label a cluster.
            
            The value should be chosen in such a way that special values can be resolved:
            * index_offset - 1 indicates an object belongs to no cluster.
            * index_offset - 2 indicates an object belongs to the noise category.
            
            Setting for instance index_offset to 1 recovers the commonly used
            case that objects of the noise category get the value of -1 and points of the
            unassigned category get the value 0.
        targets(NX_UINT):
          unit: NX_UNITLESS
          doc: |
            The evaporation (sequence) id (aka evaporation_id) to figure out
            which ions from the reconstruction were considered targets. The length
            of this array is not necessarily n_ions.
            Instead, it is the value of cardinality.
          dimensions:
            rank: 1
            dim: (i,)
        
        # quantities for debugging purposes
        number_of_solutions(NX_UINT):
          exists: optional
          unit: NX_UNITLESS
          doc: |
            The number of solutions found for each target. Typically,
            this value is 1 in which case the field can be omitted.
            Otherwise, this array is the concatenated set of values of solution
            tuples for each target that can be used to decode model_labels,
            core_sample_indices, and weight.
          dimensions:
            rank: 1
            dim: (i,)
        model_labels(NX_INT):
          exists: optional
          unit: NX_UNITLESS
          doc: |
            The raw labels from the DBScan clustering backend process.
            The length of this array is not necessarily n_ions.
            Instead, it is typically the value of cardinality provided that each
            target has only one associated cluster. If targets are assigned to
            multiple cluster this array is as long as the total number of solutions
            found and
          dimensions:
            rank: 1
            dim: (k,)
        core_sample_indices(NX_INT):
          exists: optional
          unit: NX_UNITLESS
          doc: |
            The raw array of core sample indices which specify which of the
            targets are core points.
          dimensions:
            rank: 1
            dim: (k,)
        numerical_labels(NX_UINT):
          unit: NX_UNITLESS
          doc: |
            Numerical label for each target (member in the set) aka cluster identifier.
          dimensions:
            rank: 1
            dim: (k,)
        categorical_labels(NX_CHAR):
          exists: optional
          doc: |
            Categorical label(s) for each target (member in the set) aka cluster name(s).
          dimensions:
            rank: 1
            dim: (k,)
        weights(NX_NUMBER):
          exists: optional
          unit: NX_UNITLESS
          doc: |
            Weights for each target that specifies how probable the target is assigned to
            a specific cluster.
            
            For the DBScan algorithm and atom probe tomography this value is the
            multiplicity of each ion with respect to the cluster. That is how many times
            should the position of the ion be accounted for because the ion is e.g. a
            molecular ion with several elements or nuclides of requested type.
          dimensions:
            rank: 1
            dim: (k,)
        is_noise(NX_BOOLEAN):
          exists: optional
          doc: |
            Are targets assigned to the noise category or not.
          dimensions:
            rank: 1
            dim: (k,)
        is_core(NX_BOOLEAN):
          exists: optional
          doc: |
            Are targets assumed a core point.
          dimensions:
            rank: 1
            dim: (k,)
        statistics(NXprocess):
          exists: recommended
          doc: |
            In addition to the detailed storage which members were grouped to which
            feature here summary statistics are stored that communicate e.g. how many
            cluster were found.
          
          # at the level of the set of targets
          number_of_targets(NX_UINT):
            unit: NX_UNITLESS
            doc: |
              Total number of targets in the set, i.e. ions that were filtered
              and considered in this cluster analysis.
          number_of_noise_members(NX_UINT):
            unit: NX_UNITLESS
            doc: |
              Total number of members in the set which are categorized as noise.
          number_of_core_members(NX_UINT):
            unit: NX_UNITLESS
            doc: |
              Total number of members in the set which are categorized as a core point.
          number_of_features(NX_UINT):
            unit: NX_UNITLESS
            doc: |
              Total number of clusters (excluding noise and unassigned).
          
          # at the level of the feature set
          indices_feature(NX_INT):
            unit: NX_UNITLESS
            doc: |
              Numerical identifier of each feature aka cluster_id.
            dimensions:
              rank: 1
              dim: (n_feat,)
          number_of_members(NX_UINT):
            unit: NX_UNITLESS
            doc: |
              Number of members for each feature.
            dimensions:
              rank: 1
              dim: (n_feat,)
    
    # ADD FURTHER RESULTS along the same pattern for e.g. OPTICS and HDBSCAN
    common(NXapm_paraprobe_tool_common):
      status(NX_CHAR):
      (NXprogram):
        exists: ['min', '1', 'max', 'unbounded']
        program(NX_CHAR):
          \@version(NX_CHAR):
      profiling(NXcs_profiling):
        exists: recommended
        start_time(NX_DATE_TIME):
        end_time(NX_DATE_TIME):
        total_elapsed_time(NX_FLOAT):
        current_working_directory(NX_CHAR):
        number_of_processes(NX_UINT):
        number_of_threads(NX_UINT):
        number_of_gpus(NX_UINT):
      (NXuser):
        exists: ['min', '0', 'max', 'unbounded']
        doc: |
          If used, metadata of at least the person who performed this analysis.
        name(NX_CHAR):
      coordinate_system_set(NXcoordinate_system_set):
        exists: ['min', '1', 'max', '1']
        paraprobe(NXcoordinate_system):
          type(NX_CHAR):
          handedness(NX_CHAR):
          x(NX_NUMBER):
            unit: NX_LENGTH
            dimensions:
              rank: 1
              dim: (3,)
          y(NX_NUMBER):
            unit: NX_LENGTH
            dimensions:
              rank: 1
              dim: (3,)
          z(NX_NUMBER):
            unit: NX_LENGTH
            dimensions:
              rank: 1
              dim: (3,)

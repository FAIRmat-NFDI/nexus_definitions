category: application
doc: |
  Application definition for storing results of the SCORE cellular automata model.
  
  The SCORE cellular automata model for primary recrystallization is an example
  of a typical materials engineering application used within the field of so-called
  Integral Computational Materials Engineering (ICME) whereby one can simulate
  the evolution of microstructures.
  
  Specifically the SCORE model can be used to simulate the growth of nuclei during
  static recrystallization. The model is described in the literature:
  
  * `M. KÃ¼hbach et al. <https://doi.org/10.1016/j.actamat.2016.01.068>`_
  * `C. Haase et al. <https://doi.org/10.1016/j.actamat.2015.08.057>`_
  * `M. Diehl et al. <https://doi.org/10.1088/1361-651X/ab51bd>`_
  
symbols:
  doc: |
    The symbols used in the schema to specify e.g. dimensions of arrays
  n_summary_stats: |
    The total number of summary statistic log entries
  n_b: |
    Number of boundaries of the bounding box or primitive about the computational domain
  n_p: |
    Number of parameter required for chosen orientation parameterization
  n_tex: |
    Number of texture components identified
  d: |
    Dimensionality
  c: |
    Cardinality
  n_front: |
    Number of active cells in the (recrystallization) front
  n_grains: |
    Number of grains in the computer simulation
# inspect comments behind NXmicrostructure
type: group
NXmicrostructure_score_results(NXobject):
  (NXentry):
    definition(NX_CHAR):
      enumeration: [NXmicrostructure_score_results]
    identifier_simulation(NX_UINT):
      doc: |
        Simulation ID as an alias to refer to this simulation.
    config(NXnote):
      doc: |
        Configuration file with the parameterization of the
        SCORE model that was used for this simulation.
      file_name(NX_CHAR):
      algorithm(NX_CHAR):
      checksum(NX_CHAR):
    description(NX_CHAR):
      exists: optional
      doc: |
        Discouraged free-text field to add further details to the computation.
    start_time(NX_DATE_TIME):
      doc: |
        ISO 8601 time code with local time zone offset to UTC information
        included when the simulation was started.
    end_time(NX_DATE_TIME):
      exists: recommended
      doc: |
        ISO 8601 time code with local time zone offset to UTC information
        included when the simulation ended.
    profiling(NXcs_profiling):
      exists: optional
      # consider integrating content that is currently stored in ThreadProfiling.csv
    program1(NXprogram):
      doc: |
        Name of the program with which the simulation was performed.
      program(NX_CHAR):
        \@version:
    environment(NXobject):
      exists: optional
      doc: |
        Programs and libraries representing the computational environment
      programID(NXprogram):
        exists: [min, 1, max, infty]
        nameType: partial
        program(NX_CHAR):
          \@version(NX_CHAR):
    # rotation_conventions(NXrotation_conventions):
    #   rotation_handedness(NX_CHAR):
    #   rotation_convention(NX_CHAR):
    #   euler_angle_convention(NX_CHAR):
    #   axis_angle_convention(NX_CHAR):
    #   sign_convention(NX_CHAR):
    sample_reference_frame(NXcoordinate_system):
      type:
        enumeration: [cartesian]
      handedness:
        enumeration: [right_handed]
      origin:
        enumeration: [front_bottom_left]
      x_alias:
        enumeration: [rolling_direction]
      x_direction:
        enumeration: [east]
      y_alias:
        enumeration: [transverse_direction]
      y_direction:
        enumeration: [in]
      z_alias:
        enumeration: [normal direction]
      z_direction:
        enumeration: [north]
    discretization(NXmicrostructure):
      exists: [min, 1, max, 1]
      grid(NXcg_grid):
        dimensionality(NX_POSINT):
        cardinality(NX_POSINT):
        origin(NX_NUMBER):
        symmetry(NX_CHAR):
        cell_dimensions(NX_NUMBER):
        extent(NX_UINT):
        identifier_offset(NX_INT):
      boundary(NXcg_hexahedron_set):
        doc: |
          A tight bounding box or sphere or bounding primitive about the grid.
        # a good example for a general bounding box description for such a grids of triclinic cells
        # https://docs.lammps.org/Howto_triclinic.html NXcg_polyhedron_set because a parallelepiped
        number_of_boundaries(NX_POSINT):
          unit: NX_UNITLESS
          doc: |
            How many distinct boundaries are distinguished?
            Most grids discretize a cubic or cuboidal region. In this case
            six sides can be distinguished, each making an own boundary.
        boundary_conditions(NX_INT):
          unit: NX_UNITLESS
          doc: |
            The boundary conditions for each boundary:
            
            * 0 - undefined
            * 1 - open
            * 2 - periodic
            * 3 - mirror
            * 4 - von Neumann
            * 5 - Dirichlet
            
          dim: (6,)
        boundaries:
          doc: |
            Name of the boundaries. Left, right, front, back, bottom, top,
            The field must have as many entries as there are number_of_boundaries.
          dim: (6,)
    spatiotemporalID(NXobject):
      exists: [min, 1, max, infty]  # max 1 in case of a single classical CA simulation, i.e. without solitary units
      nameType: partial
      doc: |
        Documentation of the spatiotemporal evolution for each CA domain.
        
        SCORE is a hybrid parallelized code that can evolve multiple replicas
        in parallel. The set of replicas is distributed across MPI processes.
        Each such replica is then evolved via OpenMP multi-threading.
      # the typical lean summary statistics flattened
      summary_statistics(NXprocess):
        doc: |
          Summary quantities which are the result of some post-processing of the snapshot data
          (averaging, integrating, interpolating) happening for practical and performance reasons 
          during the simulation. Place used for storing descriptors from continuum mechanics
          and thermodynamics at the scale of the entire ROI.
        kinetics(NXdata):
          exists: recommended
          doc: |
            Evolution of the recrystallized volume fraction over time.
          \@signal(NX_CHAR):
          \@axes(NX_CHAR):
          \@time_indices(NX_UINT):
          \@iteration_indices(NX_UINT):
            exists: optional
          \@temperature_indices(NX_UINT):
            exists: optional
          \@x_indices(NX_UINT):
          title(NX_CHAR):
            exists: recommended
          time(NX_FLOAT):
            doc: |
              Evolution of the physical time not to be confused with wall-clock time or profiling data.
            unit: NX_TIME
            dim: (n_summary_stats,)
          iteration(NX_INT):
            doc: |
              Iteration or increment counter.
            unit: NX_UNITLESS
            dim: (n_summary_stats,)
          temperature(NX_FLOAT):
            doc: |
              Evolution of the simulated temperature over time.
            unit: NX_TEMPERATURE
            dim: (n_summary_stats,)
          x(NX_FLOAT):
            doc: |
              Recrystallized volume fraction.
            unit: NX_DIMENSIONLESS
            dim: (n_summary_stats,)
        stress(NXdata):
          exists: optional
          type(NX_CHAR):
            doc: |
              Which type of stress.
            enumeration: [cauchy]
          tensor(NX_FLOAT):
            doc: |
              Applied external stress tensor on the ROI.
            unit: NX_ANY
            dim: (n_summary_stats, 3, 3)
        strain(NXdata):
          exists: optional
          type(NX_CHAR):
            doc: |
              Which type of strain.
          tensor(NX_FLOAT):
            doc: |
              Applied external strain tensor on the ROI.
            unit: NX_ANY
            dim: (n_summary_stats, 3, 3)
        deformation_gradient(NXprocess):
          exists: optional
          type:
            doc: |
              Which type of deformation gradient.
            enumeration: [piola]
          tensor(NX_FLOAT):
            doc: |
              Applied deformation gradient tensor on the ROI.
            unit: NX_ANY
            dim: (n_summary_stats, 3, 3)
        # magnetic_field(NXprocess):
        #   exists: optional
        #   strength(NX_FLOAT):
        #     doc: |
        #       Applied external magnetic field on the ROI.
        #     unit: NX_ANY
        #     dim: (n_summary_stats, 3, 3)
        # electrical_field(NXprocess):
        #   exists: optional
        #   strength(NX_FLOAT):
        #     doc: |
        #       Applied external electrical field on the ROI.
        #     unit: NX_ANY
        #     dim: (n_summary_stats, 3, 3)
      # the typically storage-costlier snapshot data
      microstructureID(NXmicrostructure):
        exists: [min, 1, max, infty]  # always storing the starting configuration
        nameType: partial
        time(NX_FLOAT):
        iteration(NX_UINT):
          doc: |
            Iteration or increment counter.
          unit: NX_UNITLESS
        temperature(NX_FLOAT):
          doc: |
            Simulated temperature for this snapshot.
          unit: NX_TEMPERATURE
        x(NX_FLOAT):
          doc: |
            Current recrystallized volume fraction (taking fractional infections into account).
          unit: NX_DIMENSIONLESS
        x_set(NX_FLOAT):
          doc: |
            Target value for which a snapshot was requested for the recrystallized volume fraction.
          unit: NX_DIMENSIONLESS
        # optional places to store the grid for instance if it changes
        grid(NXcg_grid):
          exists: recommended
          identifier_crystal(NX_UINT):
            exists: recommended
            doc: |
              Grain identifier for each cell.
            unit: NX_UNITLESS
            dim: (n_x, n_y, n_z)
          identifier_thread(NX_UINT):
            exists: optional
            doc: |
              Identifier of the OpenMP thread which processed this part of the grid.
            unit: NX_UNITLESS
            dim: (n_x, n_y, n_z)
        crystals(NXobject):
          representation(NX_CHAR):
            exists: recommended
          number_of_crystals(NX_UINT):
            exists: recommended
          number_of_phases(NX_UINT):
            exists: recommended
          identifier_offset_crystal(NX_INT):
            exists: recommended
          identifier_crystal(NX_INT):
            exists: recommended
            dim: (n_grains,)
          identifier_offset_phase(NX_INT):
            exists: recommended
          identifier_phase(NX_INT):
            exists: recommended
            dim: (n_grains,)
          volume(NX_FLOAT):
            doc: |
              Volume of each grain accounting also for partially transformed cells.
            unit: NX_VOLUME
            dim: (n_grains,)
          # SCORE specific
          bunge_euler(NX_FLOAT):  # only in the first snapshot
            doc: |
              Bunge-Euler angle triplets for each grain.
            unit: NX_ANGLE
            dim: (n_grains, 3)
          dislocation_density(NX_FLOAT):
            exists: recommended
            doc: |
              Current value for the dislocation density as a measure of the remaining
              stored energy in assumed crystal defects inside each grain.
            unit: NX_ANY  # 1/m^2
            dim: (n_grains,)
          is_deformed(NX_BOOLEAN):
            exists: recommended
            doc: |
              Is the grain deformed.
            dim: (n_grains,)
          is_recrystallized(NX_BOOLEAN):
            exists: recommended
            doc: |
              Is the grain recrystallized.
            dim: (n_grains,)
        recrystallization_front(NXobject):
          exists: recommended
          doc: |
            Details about those cells which in this time step represent the discrete recrystallization front.
          halo_region(NX_UINT):
            exists: optional
            doc: |
              Which cells are currently in a halo region of threads.
            unit: NX_UNITLESS
            dim: (n_front,)
          mobility_weight(NX_FLOAT):
            exists: recommended
            doc: |
              So-called mobility weight which is a scaling factor to control the
              mobility of the grain boundary that is modelled sweeping cells that
              make the discrete recrystallization front.
            unit: NX_UNITLESS
            dim: (n_front,)
          coordinate(NX_NUMBER):
            exists: recommended
            doc: |
              The x, y, z grid coordinates of each cell in the recrystallization front.
            unit: NX_UNITLESS
            dim: (n_front, 3)
          identifier_deformed_grain(NX_UINT):
            exists: recommended
            doc: |
              Grain identifier assigned to each cell in the recrystallization front.
            unit: NX_UNITLESS
            dim: (n_front,)
          identifier_recrystallized_grain(NX_UINT):
            exists: recommended
            doc: |
              Grain identifier assigned to each nucleus which affected that cell in the recrystallization front.
            unit: NX_UNITLESS
            dim: (n_front,)
          identifier_thread(NX_UINT):
            exists: optional
            doc: |
              Identifier of the OpenMP thread processing each cell in the recrystallization front.
            unit: NX_UNITLESS
            dim: (n_front,)
          infection_direction(NX_UINT):
            exists: optional
            doc: |
              Hint about the direction from which the cell was infected.
            unit: NX_UNITLESS
            dim: (n_front,)

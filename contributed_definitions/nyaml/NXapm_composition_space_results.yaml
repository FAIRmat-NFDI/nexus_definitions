category: application
doc: |
  Results of a run with Alaukik Saxena's composition space tool.
  
  This is an initial draft application definition for the common NFDI-MatWerk,
  FAIRmat infrastructure use case IUC09 how to improve the organization and
  results storage of the composition space tool and make these data at the
  same time directly understandable for research data management systems
  like NOMAD Oasis.
symbols:
  doc: |
    The symbols used in the schema to specify e.g. dimensions of arrays.
  n_voxel: |
    Number of voxel of discretized domain for analyzed part of the dataset.
  d: |
    The dimensionality of the grid.
  c: |
    The cardinality or total number of cells/grid points.
  n_clst_dict: |
    Number of terms in the composition clustering dictionary
  n_spat_dict: |
    Number of terms in the position clustering dictionary
type: group
NXapm_composition_space_results(NXobject):
  # by default for appdefs the value of the exists keyword is required unless it is explicitly specified differently
  (NXentry):
    exists: [min, 1, max, 1]
    definition(NX_CHAR):
      \@version(NX_CHAR):
      enumeration: [NXapm_composition_space_results]
    # can be used for the name of the tool and version but also
    # for if desired all the dependencies and libraries
    (NXprogram):
      exists: [min, 1, max, infty]
      program(NX_CHAR):
        \@version(NX_CHAR):
    job_pyiron_identifier(NX_CHAR):
      exists: recommended
      doc: |
        TBD, maybe how to link between pyiron state tracking and app state tracking.
    description(NX_CHAR):
      exists: optional
      doc: |
        Disencouraged place for free-text for e.g. comments.
    start_time(NX_DATE_TIME):
      doc: |
        ISO 8601 formatted time code with local time zone offset to UTC
        information included when the analysis behind this results file
        was started, i.e. when composition space tool was started as a process.
    end_time(NX_DATE_TIME):
      doc: |
        ISO 8601 formatted time code with local time zone offset to UTC
        information included when the analysis behind this results file
        were completed and composition space tool exited as a process.
    # config
    config(NXserialized):
      doc: |
        The path and name of the config file that was used for this analysis.
        TBD, this can be e.g. Alaukik's YAML file for composition space.
      type(NX_CHAR):
      path(NX_CHAR):
      algorithm(NX_CHAR):
      checksum(NX_CHAR):
    reconstruction(NXserialized):
      doc: |
        Details about the file (technology partner or community format)
        from which reconstructed ion positions were loaded.
      type(NX_CHAR):
      path(NX_CHAR):
      algorithm(NX_CHAR):
      checksum(NX_CHAR):
    ranging(NXserialized):
      doc: |
        Details about the file (technology partner or community format)
        from which ranging definitions were loaded which detail how to
        map mass-to-charge-state ratios on iontypes.
      type(NX_CHAR):
      path(NX_CHAR):
      algorithm(NX_CHAR):
      checksum(NX_CHAR):
    # results
    results_path(NX_CHAR):
      exists: optional
      doc: |
        Path to the directory where the tool should store NeXus/HDF5 results
        of this analysis. If not specified results will be stored in the
        current working directory.
    status(NX_CHAR):
      doc: |
        A statement whether the executable managed to process the analysis
        or failed prematurely. This status is written to the results file after the
        end_time at which point the executable must not compute any analysis.
        Only when this status message is present and shows `success`, the
        user should consider the results. In all other cases it might be
        that the executable has terminated prematurely or another error
        occurred.
      enumeration: [success, failure]
    (NXuser):
      exists: recommended
      doc: |
        If used, contact information and eventually details
        of at least the person who performed this analysis.
      name(NX_CHAR):
        exists: recommended
      affiliation(NX_CHAR):
        exists: optional
      (NXidentifier):
        exists: optional
      role(NX_CHAR):
        exists: optional
    (NXcoordinate_system_set):
      doc: |
        Details about coordinate systems (reference frames) used. In atom probe several coordinate
        systems have to be distinguished. Names of instances of such :ref:`NXcoordinate_system`
        should be documented explicitly and doing so by picking from the
        following controlled set of names:
        
        * composition_space
        * lab
        * specimen
        * laser
        * instrument
        * detector
        * recon
        
        The aim of this convention is to support users with contextualizing which reference
        frame each instance (coordinate system) is. If needed, instances of :ref:`NXtransformations`
        are used to detail the explicit affine transformations whereby one can convert
        representations between different reference frames.
        Inspect :ref:`NXtransformations` for further details.
    (NXcoordinate_system):
      (NXtransformations):
    # add further fields coming from using the charge state recovery
    # workflow from the ifes_apt_tc_data_modeling library
    voxelization(NXprocess):
      sequence_index(NX_POSINT):
        enumeration: [1]
      # specify the grid your using and for each ion in which cell i.e. voxel it is
      # one could also have a more sophisticated data model where there is some
      # fuzziness i.e. if an ML/AI model returns multiple values or a probability
      # how likely an ion is in which voxel, for this
      # inspect the example of the NXem_ebsd application definition
      (NXcg_grid):
        dimensionality(NX_POSINT):
          unit: NX_UNITLESS
          enumeration: [1, 2, 3]
        cardinality(NX_POSINT):
          unit: NX_UNITLESS
        
        # default behaviour, if no coordinate system defined, unclear
        # if one coordinate system is defined the origin is defined in this cs
        origin(NX_NUMBER):
          unit: NX_LENGTH
          dimensions:
            rank: 1
            dim: [[1, d]]
        symmetry:
          enumeration: [cubic]
        cell_dimensions(NX_NUMBER):
          unit: NX_LENGTH
          dimensions:
            rank: 1
            dim: [[1, d]]
        extent(NX_POSINT):
          unit: NX_UNITLESS
          dimensions:
            rank: 1
            dim: [[1, d]]
        (NXtransformations):
          exists: recommended
          doc: |
            Reference to or definition of a coordinate system with
            which the positions and directions are interpretable.
        identifier_offset(NX_INT):
          unit: NX_UNITLESS
          doc: |
            
        position(NX_NUMBER):
          unit: NX_LENGTH
          doc: |
            Position of each cell in Euclidean space.
          dimensions:
            rank: 2
            dim: [[1, c], [2, d]]
        coordinate(NX_INT):
          exists: optional
          unit: NX_DIMENSIONLESS
          dimensions:
            rank: 2
            dim: [[1, c], [2, d]]
        
        # bounding box if needed
        voxel_identifier(NX_UINT):
          unit: NX_UNITLESS
          doc: |
            For each ion, the identifier of the voxel in which the ion is located.
          dimensions:
            rank: 1
            dim: [[1, n_ions]]
      (NXion):
        exists: ['min', '0', 'max', 'unbounded']
        name:
        composition(NX_FLOAT):
          dimensions:
            rank: 1
            dim: [[1, n_voxel]]
    clustering_composition_space(NXprocess):
      doc: |
        In Alaukik's tool the GMM step.
      sequence_index(NX_POSINT):
        enumeration: [2]
      cluster_dict_keyword:
        doc: |
          The keywords of the dictionary of distinguished compositionally-
          defined cluster, e.g. the phases. Examples for keywords could be
          phase1, phase2, and so one and so forth.
        dimensions:
          rank: 1
          dim: [[1, n_clst_dict]]
      cluster_dict_value(NX_UINT):
        unit: NX_UNITLESS
        doc: |
          Resolves for each keyword in cluster_dict which integer is used to
          label something that it belongs or is assumed to represent this
          cluster.
        dimensions:
          rank: 1
          dim: [[1, n_clst_dict]]
      
      # again for fuzzy or probabilistic multi solution approaches see NXem_ebsd
      cluster_identifier(NX_UINT):
        unit: NX_UNITLESS
        doc: |
          For example if the voxel grid is used to report that there
          are voxels which are assumed to represent volume of either phase1
          or phase2, the cluster_dict_keyword would be a list with two names
          phase1 and phase2, respectively. The cluster_dict_value would be a
          list of e.g. integers 1 and 2. These could be used to build an
          array with as many entries as there are voxel and store in this array
          the respective value to encode which phase is assumed for each voxel.
        dimensions:
          rank: 1
          dim: [[1, n_voxel]]
    
    # use the fact that with e.g. XDMF one can on-the-fly reinterpret
    # a 1d array to represent an explicit 3d grid
    # default plots would be nice could directly be integrated in the results file
    clustering_real_space(NXprocess):
      doc: |
        In Alaukik's tool the DBScan step after the GMM step.
      sequence_index(NX_POSINT):
        enumeration: [3]
      cluster_dict_keyword:
        doc: |
          The keywords of the dictionary of distinguished spatially-contiguous
          clusters. Examples for keywords could be precipitate1, precipitate2,
          and so one and so forth.
        dimensions:
          rank: 1
          dim: [[1, n_spat_dict]]
      cluster_dict_value(NX_UINT):
        unit: NX_UNITLESS
        doc: |
          Resolves for each keyword in cluster_dict which integer is used to
          label something that it belongs or is assumed to represent this
          cluster.
        dimensions:
          rank: 1
          dim: [[1, n_spat_dict]]
      
      # again for fuzzy or probabilistic multi solution approaches see NXem_ebsd
      cluster_identifier(NX_UINT):
        unit: NX_UNITLESS
        doc: |
          For example if the voxel grid is used to report that there
          are voxels which are assumed to represent volume of certain precipitates,
          say we found ten precipitates and consider the rest as matrix.
          We could make a list of say matrix, precipitate1, precipitate2, ...,
          precipitate10. With cluster_dict_value then running from 0 to 10,
          i.e. matrix is flagged special as 0 and the remaining particles
          are indexed conveniently as 1, 2, ..., 10 like end users expect.
        dimensions:
          rank: 1
          dim: [[1, n_voxel]]
    
    # use the fact that with e.g. XDMF one can on-the-fly reinterpret
    # a 1d array to represent an explicit 3d grid
    # then the entire visualization just needs a smart XDMF file with
    # one section with the coordinates of the voxel center of masses
    # one section with the voxel identifier
    # one section with the "phase" identifier referring to the clustering_composition_space NXprocess group
    # one section with the "precipitate" identifier referring to the clustering_real_space NXprocess group
    # technically one should get rid of the unnecessary chunks
    # instead define an (nx, ny, nz) C-style array which whose data space
    # is reserved by the h5py library upon first call and then (if desired)
    # filled incrementally
    # the array should be chunked not with an auto-chunking but with a nx, ny, >=1 chunking
    # which will make visualization of nx, ny slices naturally fast, making the z-dimension
    # chunking as fast as large as possible (needs compromise to remain within chunk cache size)
    # will also make the orthogonal section a good compromise fast
    # data should be gzip, level 1 compressed and all the redundant parts of the current
    # output will collapse substantially
    performance(NXcs_profiling):
      current_working_directory:
      command_line_call:
        exists: optional
      start_time(NX_DATE_TIME):
        exists: recommended
      end_time(NX_DATE_TIME):
        exists: recommended
      total_elapsed_time(NX_NUMBER):
      number_of_processes(NX_POSINT):
      number_of_threads(NX_POSINT):
      number_of_gpus(NX_POSINT):
      (NXcs_computer):
        exists: recommended
        name:
          exists: recommended
        operating_system:
          \@version:
        uuid:
          exists: optional
        (NXcs_cpu):
          exists: ['min', '0', 'max', 'unbounded']
          name:
            exists: optional
          (NXfabrication):
            exists: recommended
            identifier:
              exists: optional
            capabilities:
              exists: optional
        (NXcs_gpu):
          exists: ['min', '0', 'max', 'unbounded']
          name:
            exists: optional
          (NXfabrication):
            exists: recommended
            identifier:
              exists: optional
            capabilities:
              exists: optional
        (NXcs_mm_sys):
          exists: ['min', '0', 'max', '1']
          total_physical_memory(NX_NUMBER):
        (NXcs_io_sys):
          exists: ['min', '0', 'max', '1']
          (NXcs_io_obj):
            exists: ['min', '1', 'max', 'unbounded']
            technology:
            max_physical_capacity(NX_NUMBER):
            name:
              exists: optional
            (NXfabrication):
              exists: recommended
              identifier:
                exists: optional
              capabilities:
                exists: optional
        (NXcs_profiling_event):
          start_time(NX_DATE_TIME):
            exists: optional
          end_time(NX_DATE_TIME):
            exists: optional
          description:
          elapsed_time(NX_NUMBER):
          number_of_processes(NX_POSINT):
            
            # exists: recommended
            doc: |
              Specify if it was different from the number_of_processes
              in the NXcs_profiling super class.
          number_of_threads(NX_POSINT):
            
            # exists: recommended
            doc: |
              Specify if it was different from the number_of_threads
              in the NXcs_profiling super class.
          number_of_gpus(NX_POSINT):
            
            # exists: recommended
            doc: |
              Specify if it was different from the number_of_threads
              in the NXcs_profiling super class.
          max_virtual_memory_snapshot(NX_NUMBER):
            exists: recommended
          max_resident_memory_snapshot(NX_NUMBER):
            exists: recommended

# ++++++++++++++++++++++++++++++++++ SHA HASH ++++++++++++++++++++++++++++++++++
# fe3315d020167a5d984295fad8ed2070693508cd60801e40acaac2a61f21f1b4
# <?xml version="1.0" encoding="UTF-8"?>
# <?xml-stylesheet type="text/xsl" href="nxdlformat.xsl"?>
# <!--
# # NeXus - Neutron and X-ray Common Data Format
# # 
# # Copyright (C) 2014-2022 NeXus International Advisory Committee (NIAC)
# # 
# # This library is free software; you can redistribute it and/or
# # modify it under the terms of the GNU Lesser General Public
# # License as published by the Free Software Foundation; either
# # version 3 of the License, or (at your option) any later version.
# #
# # This library is distributed in the hope that it will be useful,
# # but WITHOUT ANY WARRANTY; without even the implied warranty of
# # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# # Lesser General Public License for more details.
# #
# # You should have received a copy of the GNU Lesser General Public
# # License along with this library; if not, write to the Free Software
# # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
# #
# # For further information, see http://www.nexusformat.org
# -->
# <definition xmlns="http://definition.nexusformat.org/nxdl/3.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" category="application" name="NXapm_composition_space_results" extends="NXobject" type="group" xsi:schemaLocation="http://definition.nexusformat.org/nxdl/3.1 ../nxdl.xsd">
#     <symbols>
#         <doc>
#              The symbols used in the schema to specify e.g. dimensions of arrays.
#         </doc>
#         <symbol name="n_voxel">
#             <doc>
#                  Number of voxel of discretized domain for analyzed part of the dataset.
#             </doc>
#         </symbol>
#         <symbol name="d">
#             <doc>
#                  The dimensionality of the grid.
#             </doc>
#         </symbol>
#         <symbol name="c">
#             <doc>
#                  The cardinality or total number of cells/grid points.
#             </doc>
#         </symbol>
#         <symbol name="n_clst_dict">
#             <doc>
#                  Number of terms in the composition clustering dictionary
#             </doc>
#         </symbol>
#         <symbol name="n_spat_dict">
#             <doc>
#                  Number of terms in the position clustering dictionary
#             </doc>
#         </symbol>
#     </symbols>
#     <doc>
#          Results of a run with Alaukik Saxena's composition space tool.
#          
#          This is an initial draft application definition for the common NFDI-MatWerk,
#          FAIRmat infrastructure use case IUC09 how to improve the organization and
#          results storage of the composition space tool and make these data at the same
#          time directly understandable for NOMAD.
#          
#          This draft does no contain yet the annotations for how to also store
#          in the HDF5 file a default visualization whereby the composition grid
#          could directly be explored using H5Web. I am happy to add this ones the
#          data have been mapped on this schema, i.e. more discussion needed.
#          
#          Also iso-surfaces can be described, for paraprobe, this is a solved problem, 
#          check the respective group in the NXapm_paraprobe_results_nanochem data
#          schema/application definition.
#     </doc>
#     <!--by default for appdefs the value of the exists keyword is required
# unless it is explicitly specified differently-->
#     <group type="NXentry" minOccurs="1" maxOccurs="1">
#         <attribute name="version">
#             <doc>
#                  Version specifier of this application definition.
#             </doc>
#         </attribute>
#         <field name="definition">
#             <doc>
#                  Official NeXus NXDL schema with which this file was written.
#             </doc>
#             <enumeration>
#                 <item value="NXapm_composition_space_results"/>
#             </enumeration>
#         </field>
#         <!--can be used for the name of the tool and version but also
# for if desired all the dependencies and libraries-->
#         <group type="NXprogram" minOccurs="1" maxOccurs="unbounded">
#             <field name="program">
#                 <attribute name="version"/>
#             </field>
#         </group>
#         <field name="job_pyiron_identifier" recommended="true">
#             <doc>
#                  TBD, maybe how to link between pyiron state tracking and app state tracking
#             </doc>
#         </field>
#         <field name="description" optional="true">
#             <doc>
#                  Disencouraged place for free-text for e.g. comments.
#             </doc>
#         </field>
#         <field name="start_time" type="NX_DATE_TIME">
#             <doc>
#                  ISO 8601 formatted time code with local time zone offset to UTC
#                  information included when the analysis behind this results file
#                  was started, i.e. when composition space tool was started as a process.
#             </doc>
#         </field>
#         <field name="end_time" type="NX_DATE_TIME">
#             <doc>
#                  ISO 8601 formatted time code with local time zone offset to UTC
#                  information included when the analysis behind this results file
#                  were completed and composition space tool exited as a process.
#             </doc>
#         </field>
#         <field name="config_filename">
#             <doc>
#                  The path and name of the config file for this analysis.
#                  TBD, this can be e.g. Alaukik's YAML file for composition space.
#             </doc>
#             <!--one could also wrap the entire triple of NXprocess (voxelization, gmm, real space)
# by a parent NXprocess whereby one could store the results of multiple analyses
# runs of the tool in the same individually documented way for as many parameter
# runs as desired...-->
#             <attribute name="version">
#                 <doc>
#                      At least SHA256 strong hash of the specific config_file for
#                      tracking provenance.
#                 </doc>
#             </attribute>
#         </field>
#         <group name="dataset" type="NXapm_input_reconstruction">
#             <field name="filename">
#                 <doc>
#                      The path and name of the file (technology partner or community format)
#                      from which reconstructed ion positions were loaded.
#                 </doc>
#                 <attribute name="version"/>
#             </field>
#         </group>
#         <group name="iontypes" type="NXapm_input_ranging">
#             <field name="filename">
#                 <doc>
#                      The path and name of the file (technology partner or community format
#                      from which ranging definitions, i.e. how to map mass-to-
#                      charge-state ratios on iontypes were loaded.
#                 </doc>
#                 <attribute name="version"/>
#             </field>
#         </group>
#         <field name="results_path" optional="true">
#             <doc>
#                  Path to the directory where the tool should store NeXus/HDF5 results
#                  of this analysis. If not specified results will be stored in the
#                  current working directory.
#             </doc>
#         </field>
#         <field name="status">
#             <doc>
#                  A statement whether the executable managed to process the analysis
#                  or failed prematurely.
#                  
#                  This status is written to the results file after the end_time
#                  at which point the executable must not compute any analysis.
#                  Only when this status message is present and shows `success`, the
#                  user should consider the results. In all other cases it might be
#                  that the executable has terminated prematurely or another error
#                  occurred.
#             </doc>
#             <enumeration>
#                 <item value="success"/>
#                 <item value="failure"/>
#             </enumeration>
#         </field>
#         <group type="NXuser" recommended="true">
#             <doc>
#                  If used, contact information and eventually details
#                  of at least the person who performed this analysis.
#             </doc>
#             <field name="name"/>
#             <field name="affiliation" recommended="true"/>
#             <field name="address" optional="true"/>
#             <field name="email" recommended="true"/>
#             <field name="orcid" recommended="true"/>
#             <field name="orcid_platform" recommended="true"/>
#             <field name="telephone_number" optional="true"/>
#             <field name="role" recommended="true"/>
#             <field name="social_media_name" optional="true"/>
#             <field name="social_media_platform" optional="true"/>
#         </group>
#         <group type="NXcoordinate_system_set" optional="true">
#             <doc>
#                  Details about the coordinate system conventions used.
#             </doc>
#             <group type="NXtransformations" minOccurs="1" maxOccurs="unbounded">
#                 <doc>
#                      The individual coordinate systems which should be used.
#                      Some suggestions follow, e.g. that field names should be prefixed
#                      with the following controlled terms indicating which individual
#                      coordinate system is described:
#                      
#                      * world
#                      * composition_space
#                      * lab
#                      * specimen
#                      * laser
#                      * leap
#                      * detector
#                      * recon
#                 </doc>
#             </group>
#         </group>
#         <group name="voxelization" type="NXprocess">
#             <field name="sequence_index" type="NX_POSINT">
#                 <enumeration>
#                     <item value="1"/>
#                 </enumeration>
#             </field>
#             <!--specify the grid your using and for each ion in which cell i.e. voxel it is
# one could also have a more sophisticated data model where there is some
# fuzziness i.e. if an ML/AI model returns multiple values or a probability
# how likely an ion is in which voxel, for this
# inspect the example of the NXem_ebsd application definition-->
#             <group type="NXcg_grid">
#                 <field name="dimensionality" type="NX_POSINT" units="NX_UNITLESS">
#                     <enumeration>
#                         <item value="1"/>
#                         <item value="2"/>
#                         <item value="3"/>
#                     </enumeration>
#                 </field>
#                 <field name="cardinality" type="NX_POSINT" units="NX_UNITLESS"/>
#                 <!--default behaviour, if no coordinate system defined, unclear
# if one coordinate system is defined the origin is defined in this cs-->
#                 <field name="origin" type="NX_NUMBER" units="NX_LENGTH">
#                     <dimensions rank="1">
#                         <dim index="1" value="d"/>
#                     </dimensions>
#                 </field>
#                 <field name="symmetry">
#                     <enumeration>
#                         <item value="cubic"/>
#                     </enumeration>
#                 </field>
#                 <field name="cell_dimensions" type="NX_NUMBER" units="NX_LENGTH">
#                     <dimensions rank="1">
#                         <dim index="1" value="d"/>
#                     </dimensions>
#                 </field>
#                 <field name="extent" type="NX_POSINT" units="NX_UNITLESS">
#                     <dimensions rank="1">
#                         <dim index="1" value="d"/>
#                     </dimensions>
#                 </field>
#                 <group type="NXtransformations" recommended="true">
#                     <doc>
#                          Reference to or definition of a coordinate system with
#                          which the positions and directions are interpretable.
#                     </doc>
#                 </group>
#                 <field name="identifier_offset" type="NX_INT" units="NX_UNITLESS">
#                     <doc>
#                          
#                     </doc>
#                 </field>
#                 <field name="position" type="NX_NUMBER" units="NX_LENGTH">
#                     <doc>
#                          Position of each cell in Euclidean space.
#                     </doc>
#                     <dimensions rank="2">
#                         <dim index="1" value="c"/>
#                         <dim index="2" value="d"/>
#                     </dimensions>
#                 </field>
#                 <field name="coordinate" type="NX_INT" optional="true" units="NX_DIMENSIONLESS">
#                     <dimensions rank="2">
#                         <dim index="1" value="c"/>
#                         <dim index="2" value="d"/>
#                     </dimensions>
#                 </field>
#                 <!--bounding box if needed-->
#                 <field name="voxel_identifier" type="NX_UINT" units="NX_UNITLESS">
#                     <doc>
#                          For each ion, the identifier of the voxel in which the ion is located.
#                     </doc>
#                     <dimensions rank="1">
#                         <dim index="1" value="n_ions"/>
#                     </dimensions>
#                 </field>
#             </group>
#             <group type="NXion" minOccurs="0" maxOccurs="unbounded">
#                 <field name="name"/>
#                 <field name="composition" type="NX_FLOAT">
#                     <dimensions rank="1">
#                         <dim index="1" value="n_voxel"/>
#                     </dimensions>
#                 </field>
#             </group>
#         </group>
#         <group name="clustering_composition_space" type="NXprocess">
#             <doc>
#                  In Alaukik's tool the GMM step.
#             </doc>
#             <field name="sequence_index" type="NX_POSINT">
#                 <enumeration>
#                     <item value="2"/>
#                 </enumeration>
#             </field>
#             <field name="cluster_dict_keyword">
#                 <doc>
#                      The keywords of the dictionary of distinguished compositionally-
#                      defined cluster, e.g. the phases. Examples for keywords could be
#                      phase1, phase2, and so one and so forth.
#                 </doc>
#                 <dimensions rank="1">
#                     <dim index="1" value="n_clst_dict"/>
#                 </dimensions>
#             </field>
#             <field name="cluster_dict_value" type="NX_UINT" units="NX_UNITLESS">
#                 <doc>
#                      Resolves for each keyword in cluster_dict which integer is used to
#                      label something that it belongs or is assumed to represent this
#                      cluster.
#                 </doc>
#                 <dimensions rank="1">
#                     <dim index="1" value="n_clst_dict"/>
#                 </dimensions>
#             </field>
#             <!--again for fuzzy or probabilistic multi solution approaches see NXem_ebsd-->
#             <field name="cluster_identifier" type="NX_UINT" units="NX_UNITLESS">
#                 <doc>
#                      For example if the voxel grid is used to report that there
#                      are voxels which are assumed to represent volume of either phase1
#                      or phase2, the cluster_dict_keyword would be a list with two names
#                      phase1 and phase2, respectively. The cluster_dict_value would be a
#                      list of e.g. integers 1 and 2. These could be used to build an
#                      array with as many entries as there are voxel and store in this array
#                      the respective value to encode which phase is assumed for each voxel.
#                 </doc>
#                 <dimensions rank="1">
#                     <dim index="1" value="n_voxel"/>
#                 </dimensions>
#             </field>
#         </group>
#         <!--use the fact that with e.g. XDMF one can on-the-fly reinterpret
# a 1d array to represent an explicit 3d grid
# default plots would be nice could directly be integrated in the results file-->
#         <group name="clustering_real_space" type="NXprocess">
#             <doc>
#                  In Alaukik's tool the DBScan step after the GMM step.
#             </doc>
#             <field name="sequence_index" type="NX_POSINT">
#                 <enumeration>
#                     <item value="3"/>
#                 </enumeration>
#             </field>
#             <field name="cluster_dict_keyword">
#                 <doc>
#                      The keywords of the dictionary of distinguished spatially-contiguous
#                      clusters. Examples for keywords could be precipitate1, precipitate2,
#                      and so one and so forth.
#                 </doc>
#                 <dimensions rank="1">
#                     <dim index="1" value="n_spat_dict"/>
#                 </dimensions>
#             </field>
#             <field name="cluster_dict_value" type="NX_UINT" units="NX_UNITLESS">
#                 <doc>
#                      Resolves for each keyword in cluster_dict which integer is used to
#                      label something that it belongs or is assumed to represent this
#                      cluster.
#                 </doc>
#                 <dimensions rank="1">
#                     <dim index="1" value="n_spat_dict"/>
#                 </dimensions>
#             </field>
#             <!--again for fuzzy or probabilistic multi solution approaches see NXem_ebsd-->
#             <field name="cluster_identifier" type="NX_UINT" units="NX_UNITLESS">
#                 <doc>
#                      For example if the voxel grid is used to report that there
#                      are voxels which are assumed to represent volume of certain precipitates,
#                      say we found ten precipitates and consider the rest as matrix.
#                      We could make a list of say matrix, precipitate1, precipitate2, ...,
#                      precipitate10. With cluster_dict_value then running from 0 to 10,
#                      i.e. matrix is flagged special as 0 and the remaining particles
#                      are indexed conveniently as 1, 2, ..., 10 like end users expect.
#                 </doc>
#                 <dimensions rank="1">
#                     <dim index="1" value="n_voxel"/>
#                 </dimensions>
#             </field>
#         </group>
#         <!--use the fact that with e.g. XDMF one can on-the-fly reinterpret
# a 1d array to represent an explicit 3d grid
# then the entire visualization just needs a smart XDMF file with
# one section with the coordinates of the voxel center of masses
# one section with the voxel identifier
# one section with the "phase" identifier referring to the clustering_composition_space NXprocess group
# one section with the "precipitate" identifier referring to the clustering_real_space NXprocess group
# technically one should get rid of the unnecessary chunks
# instead define an (nx, ny, nz) C-style array which whose data space
# is reserved by the h5py library upon first call and then (if desired)
# filled incrementally
# the array should be chunked not with an auto-chunking but with a nx, ny, >=1 chunking
# which will make visualization of nx, ny slices naturally fast, making the z-dimension
# chunking as fast as large as possible (needs compromise to remain within chunk cache size)
# will also make the orthogonal section a good compromise fast
# data should be gzip, level 1 compressed and all the redundant parts of the current
# output will collapse substantially-->
#         <group name="performance" type="NXcs_profiling">
#             <field name="current_working_directory"/>
#             <field name="command_line_call" optional="true"/>
#             <field name="start_time" type="NX_DATE_TIME" recommended="true"/>
#             <field name="end_time" type="NX_DATE_TIME" recommended="true"/>
#             <field name="total_elapsed_time" type="NX_NUMBER"/>
#             <field name="number_of_processes" type="NX_POSINT"/>
#             <field name="number_of_threads" type="NX_POSINT"/>
#             <field name="number_of_gpus" type="NX_POSINT"/>
#             <group type="NXcs_computer" recommended="true">
#                 <field name="name" recommended="true"/>
#                 <field name="operating_system">
#                     <attribute name="version"/>
#                 </field>
#                 <field name="uuid" optional="true"/>
#                 <group type="NXcs_cpu" minOccurs="0" maxOccurs="unbounded">
#                     <field name="name" optional="true"/>
#                     <group type="NXfabrication" recommended="true">
#                         <field name="identifier" optional="true"/>
#                         <field name="capabilities" optional="true"/>
#                     </group>
#                 </group>
#                 <group type="NXcs_gpu" minOccurs="0" maxOccurs="unbounded">
#                     <field name="name" optional="true"/>
#                     <group type="NXfabrication" recommended="true">
#                         <field name="identifier" optional="true"/>
#                         <field name="capabilities" optional="true"/>
#                     </group>
#                 </group>
#                 <group type="NXcs_mm_sys" minOccurs="0" maxOccurs="1">
#                     <field name="total_physical_memory" type="NX_NUMBER"/>
#                 </group>
#                 <group type="NXcs_io_sys" minOccurs="0" maxOccurs="1">
#                     <group type="NXcs_io_obj" minOccurs="1" maxOccurs="unbounded">
#                         <field name="technology"/>
#                         <field name="max_physical_capacity" type="NX_NUMBER"/>
#                         <field name="name" optional="true"/>
#                         <group type="NXfabrication" recommended="true">
#                             <field name="identifier" optional="true"/>
#                             <field name="capabilities" optional="true"/>
#                         </group>
#                     </group>
#                 </group>
#                 <group type="NXcs_profiling_event">
#                     <field name="start_time" type="NX_DATE_TIME" optional="true"/>
#                     <field name="end_time" type="NX_DATE_TIME" optional="true"/>
#                     <field name="description"/>
#                     <field name="elapsed_time" type="NX_NUMBER"/>
#                     <field name="number_of_processes" type="NX_POSINT">
#                         <!--exists: recommended-->
#                         <doc>
#                              Specify if it was different from the number_of_processes
#                              in the NXcs_profiling super class.
#                         </doc>
#                     </field>
#                     <field name="number_of_threads" type="NX_POSINT">
#                         <!--exists: recommended-->
#                         <doc>
#                              Specify if it was different from the number_of_threads
#                              in the NXcs_profiling super class.
#                         </doc>
#                     </field>
#                     <field name="number_of_gpus" type="NX_POSINT">
#                         <!--exists: recommended-->
#                         <doc>
#                              Specify if it was different from the number_of_threads
#                              in the NXcs_profiling super class.
#                         </doc>
#                     </field>
#                     <field name="max_virtual_memory_snapshot" type="NX_NUMBER" recommended="true"/>
#                     <field name="max_resident_memory_snapshot" type="NX_NUMBER" recommended="true"/>
#                 </group>
#             </group>
#         </group>
#     </group>
# </definition>

category: base
doc: |
  Base class to store an inverse pole figure (IPF) mapping (IPF map).
symbols:
  n_z: |
    Number of pixel along the z slowest direction.
  n_y: |
    Number of pixel along the y slow direction.
  n_x: |
    Number of pixel along the x fast direction.
  n_rgb: |
    Number of RGB values along the fastest direction, always three.
  d: |
    Dimensionality of the mapping (either 2 or 3).
type: group
NXmicrostructure_ipf(NXprocess):
  depends_on(NX_CHAR):
    doc:
    - |
      Reference to an :ref:`NXcoordinate_system` in which the projection_direction is defined.
      
      If the field depends_on is not provided but parents of the instance of this base class or its
      specializations define an instance of :ref:`NXcoordinate_system`, projection_direction
      is defined in this coordinate system.
      
      If nothing is provided it is assumed that projection_direction is defined in the McStas coordinate system.
  projection_direction(NX_NUMBER):
    doc: |
      The direction along which orientations are projected.
    unit: NX_UNITLESS
    dim: (3,)
  input_grid(NXcg_grid):
    doc: |
      Details about the original grid.
      
      Here original grid means the grid for which the IPF map was computed when that
      IPF map was exported from the tech partner's file format representation.
  output_grid(NXcg_grid):
    doc: |
      Details about the grid onto which the IPF is recomputed.
      
      Rescaling the visualization of the IPF map may be needed to enable
      visualization in specific software tools like H5Web.
  interpolation(NX_CHAR):
    doc: |
      How where orientation values at positions of input_grid computed to values on output_grid.
      
      Nearest neighbour means the orientation of the closed (Euclidean distance) grid point of the input_grid was taken.
    enumeration: [nearest_neighbour]
  map(NXdata):
    doc: |
      Inverse pole figure mapping.
      
      phase. No ipf_mapID instances for non-indexed scan points as these are
      by definition assigned the null phase with phase_identifier 0.
      Inspect the definition of :ref:`NXcrystal_structure` and its field
      phase_identifier for further details.
      
      Details about possible regridding and associated interpolation
      during the computation of the IPF map visualization can be stored
      using the input_grid, output_grid, and interpolation fields.
      
      The main purpose of this map is to offer a normalized default representation
      of the IPF map for consumption by a research data management system (RDMS).
      This is aligned with the first aim of :ref:`NXmicrostructure_ipf`, to bring colleagues
      and users of IPF maps together to discuss which pieces of information need storage.
      
      We are convinced a step-by-step design and community-driven discussion is a practical
      strategy to work towards an interoperable description and data model for exchanging
      IPF maps as a specific community-accepted method to convey orientation maps.
      
      With this design the individual RDMS solutions and tools can still continue
      to support specific custom data analyses workflow and routes but at least
      there is one common understanding which enables also those users who are
      not necessarily experts in all the details of the underlying techniques an
      understanding if the dataset is worth to become reused or repurposed.
    # \@signal: data
    # \@axes: [axis_y, axis_x]
    # \@axis_x_indices: 0
    # \@axis_y_indices: 1
    data(NX_NUMBER):
      # assume a mapping with step size 0.5 micron
      # we need to distinguish
      # pixel position, i.e. 0, 1, 2, 3, unit px
      #   answers in which pixel on the map but map is disconnected from sample surface context
      # calibrated pixel position 0., 0.5, 1.0, 1.5, unit micron
      #   answers in addition physical dimensions (relevant to get crystal extent etc.) but still disconnected from sample surface context
      # calibrated pixel position including the offset of the original coordinate system
      #   answers everything would enable one to point if still in the microscope where on the sample surface each pixel is located
      # tech partners oftentimes do not report to more than calibrated pixel position
      doc: |
        Inverse pole figure color code for each map coordinate.
      unit: NX_UNITLESS
      dim: (n_y, n_x, 3)  # | (n_z, n_y, n_x, 3)
    axis_z(NX_NUMBER):
      doc: |
        Pixel center coordinate calibrated for step size along the z axis of the map.
      unit: NX_LENGTH
      dim: (n_z,)
      # \@long_name(NX_CHAR):
    axis_y(NX_NUMBER):
      unit: NX_LENGTH
      doc: |
        Pixel center coordinate calibrated for step size along the y axis of the map.
      dim: (n_y,)
      # \@long_name(NX_CHAR):
    axis_x(NX_NUMBER):
      unit: NX_LENGTH
      doc: |
        Pixel center coordinate calibrated for step size along the x axis of the map.
      dim: (n_x,)
      # \@long_name(NX_CHAR):
    # title:
  legend(NXdata):
    doc: |
      The color code which maps colors to orientation in the fundamental zone.
      
      For each stereographic standard triangle (SST), i.e. a rendering of the
      fundamental zone of the crystal-symmetry-reduced orientation space
      SO3, it is possible to define a color model which assigns a color to each
      point in the fundamental zone.
      
      Different mapping models are used. These implement (slightly) different
      scaling relations. Differences exist across representations of tech partners.
      
      Differences are which base colors of the RGB color model are placed in
      which extremal position of the SST and where the white point is located.
      
      For further details see:
      
      * [G. Nolze et al.](https://doi.org/10.1107/S1600576716012942)
      * [S. Patala et al.](https://doi.org/10.1016/j.pmatsci.2012.04.002).
      
      Details are implementation-specific and not standardized yet.
      
      Given that the SST has a complicated geometry, it can not yet be
      visualized using tools like H5Web, which is why for now the matrix
      of a rasterized image which is rendered by the backend tool gets
      copied into an RGB matrix to offer a default plot.
    # \@signal: data
    # \@axes: [axis_y, axis_x]
    # \@axis_x_indices: 0
    # \@axis_y_indices: 1
    data(NX_NUMBER):
      # hehe, but can be larger than one but could also be an NX_DIMENSIONLESS !
      doc: |
        Inverse pole figure color code for each map coordinate.
      unit: NX_UNITLESS
      dim: (n_y, n_x, 3)
    axis_y(NX_NUMBER):
      doc: |
        Pixel along the y-axis.
      unit: NX_UNITLESS
      dim: (n_y,)
      # \@long_name(NX_CHAR):
    axis_x(NX_NUMBER):
      doc: |
        Pixel along the x-axis.
      unit: NX_UNITLESS
      dim: (n_x,)
      # \@long_name(NX_CHAR):
    # title:

# for further contextualization see comments in NXms_ipf.yaml
# https://github.com/FAIRmat-NFDI/nexus_definitions/commit/26d4faa5c6950161e48f0672f3fdfd8c9bc907e2
